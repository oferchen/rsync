#![deny(unsafe_code)]

use crate::frontend::execution::chown::ParsedChown;
use crate::frontend::progress::ProgressSetting;
use rsync_core::client::{
    AddressMode, BindAddress, DeleteMode, HumanReadableMode, RemoteFallbackArgs, TransferTimeout,
};
use rsync_logging::MessageSink;
use rsync_protocol::ProtocolVersion;
use std::ffi::OsString;
use std::io::Write;
use std::path::PathBuf;

use super::super::fallback;

pub(crate) struct FallbackArgumentsContext<'a> {
    pub(crate) required: bool,
    pub(crate) info: &'a [OsString],
    pub(crate) debug_flags: &'a [OsString],
    pub(crate) protect_args: Option<bool>,
    pub(crate) progress_setting: ProgressSetting,
    pub(crate) delete_mode: DeleteMode,
    pub(crate) delete_excluded: bool,
    pub(crate) max_delete_limit: Option<u64>,
    pub(crate) password_file: &'a Option<PathBuf>,
    pub(crate) dry_run: bool,
    pub(crate) list_only: bool,
    pub(crate) remote_shell: Option<&'a OsString>,
    pub(crate) remote_options: &'a [OsString],
    pub(crate) connect_program: Option<&'a OsString>,
    pub(crate) daemon_port: Option<u16>,
    pub(crate) bind_address: Option<&'a BindAddress>,
    pub(crate) human_readable: Option<HumanReadableMode>,
    pub(crate) archive: bool,
    pub(crate) min_size: &'a Option<OsString>,
    pub(crate) max_size: &'a Option<OsString>,
    pub(crate) checksum: bool,
    pub(crate) checksum_choice_arg: Option<&'a OsString>,
    pub(crate) checksum_seed: Option<u32>,
    pub(crate) size_only: bool,
    pub(crate) ignore_existing: bool,
    pub(crate) ignore_missing_args: bool,
    pub(crate) update: bool,
    pub(crate) modify_window: Option<u64>,
    pub(crate) compress: bool,
    pub(crate) compress_disabled: bool,
    pub(crate) compress_level_cli: Option<&'a OsString>,
    pub(crate) skip_compress: Option<&'a OsString>,
    pub(crate) parsed_chown: Option<&'a ParsedChown>,
    pub(crate) owner: Option<bool>,
    pub(crate) group: Option<bool>,
    pub(crate) chmod: &'a [OsString],
    pub(crate) perms: Option<bool>,
    pub(crate) super_mode: Option<bool>,
    pub(crate) times: Option<bool>,
    pub(crate) omit_dir_times: Option<bool>,
    pub(crate) omit_link_times: Option<bool>,
    pub(crate) numeric_ids_option: Option<bool>,
    pub(crate) hard_links: Option<bool>,
    pub(crate) copy_links: Option<bool>,
    pub(crate) copy_dirlinks: bool,
    pub(crate) copy_unsafe_links: Option<bool>,
    pub(crate) keep_dirlinks: Option<bool>,
    pub(crate) safe_links: bool,
    pub(crate) sparse: Option<bool>,
    pub(crate) devices: Option<bool>,
    pub(crate) specials: Option<bool>,
    pub(crate) relative: Option<bool>,
    pub(crate) one_file_system: Option<bool>,
    pub(crate) implied_dirs: Option<bool>,
    pub(crate) mkpath: bool,
    pub(crate) prune_empty_dirs: Option<bool>,
    pub(crate) verbosity: u8,
    pub(crate) progress_enabled: bool,
    pub(crate) stats: bool,
    pub(crate) partial: bool,
    pub(crate) preallocate: bool,
    pub(crate) delay_updates: bool,
    pub(crate) partial_dir: Option<&'a PathBuf>,
    pub(crate) temp_dir: Option<&'a PathBuf>,
    pub(crate) backup: bool,
    pub(crate) backup_dir: &'a Option<OsString>,
    pub(crate) backup_suffix: &'a Option<OsString>,
    pub(crate) link_dests: &'a [PathBuf],
    pub(crate) remove_source_files: bool,
    pub(crate) append: Option<bool>,
    pub(crate) append_verify: bool,
    pub(crate) inplace: Option<bool>,
    pub(crate) msgs_to_stderr: bool,
    pub(crate) whole_file_option: Option<bool>,
    pub(crate) fallback_bwlimit: Option<&'a OsString>,
    pub(crate) excludes: &'a [OsString],
    pub(crate) includes: &'a [OsString],
    pub(crate) exclude_from: &'a [OsString],
    pub(crate) include_from: &'a [OsString],
    pub(crate) filters: &'a [OsString],
    pub(crate) rsync_filter_shortcuts: u8,
    pub(crate) compare_destinations: &'a [OsString],
    pub(crate) copy_destinations: &'a [OsString],
    pub(crate) link_destinations: &'a [OsString],
    pub(crate) cvs_exclude: bool,
    pub(crate) files_from_used: bool,
    pub(crate) file_list_entries: &'a [OsString],
    pub(crate) from0: bool,
    pub(crate) desired_protocol: Option<ProtocolVersion>,
    pub(crate) timeout: TransferTimeout,
    pub(crate) connect_timeout: TransferTimeout,
    pub(crate) fallback_out_format: Option<&'a OsString>,
    pub(crate) no_motd: bool,
    pub(crate) address_mode: AddressMode,
    pub(crate) rsync_path: Option<&'a OsString>,
    pub(crate) remainder: &'a [OsString],
    #[cfg(feature = "acl")]
    pub(crate) acls: Option<bool>,
    #[cfg(feature = "xattr")]
    pub(crate) xattrs: Option<bool>,
    pub(crate) itemize_changes: bool,
}

pub(crate) fn build_fallback_arguments<Err>(
    context: FallbackArgumentsContext<'_>,
    stderr: &mut MessageSink<Err>,
) -> Result<Option<RemoteFallbackArgs>, i32>
where
    Err: Write,
{
    if !context.required {
        return Ok(None);
    }

    let append_for_fallback = if context.append_verify {
        Some(true)
    } else {
        context.append
    };

    let delete_for_fallback = context.delete_mode.is_enabled()
        || context.delete_excluded
        || context.max_delete_limit.is_some();

    let fallback_inputs = fallback::FallbackInputs {
        required: context.required,
        info_flags: context.info.to_vec(),
        debug_flags: context.debug_flags.to_vec(),
        protect_args: context.protect_args,
        progress_setting: context.progress_setting,
        delete_mode: context.delete_mode,
        delete_excluded: context.delete_excluded,
        max_delete_limit: context.max_delete_limit,
        password_file: context.password_file.clone(),
        dry_run: context.dry_run,
        list_only: context.list_only,
        remote_shell: context.remote_shell.cloned(),
        remote_options: context.remote_options.to_vec(),
        connect_program: context.connect_program.cloned(),
        daemon_port: context.daemon_port,
        bind_address: context.bind_address.cloned(),
        human_readable: context.human_readable,
        archive: context.archive,
        delete_for_fallback,
        min_size: context.min_size.clone(),
        max_size: context.max_size.clone(),
        checksum: context.checksum,
        checksum_choice_arg: context.checksum_choice_arg.cloned(),
        checksum_seed: context.checksum_seed,
        size_only: context.size_only,
        ignore_existing: context.ignore_existing,
        ignore_missing_args: context.ignore_missing_args,
        update: context.update,
        modify_window: context.modify_window,
        compress: context.compress,
        compress_disabled: context.compress_disabled,
        compress_level_cli: context.compress_level_cli.cloned(),
        skip_compress: context.skip_compress.cloned(),
        chown_spec: context.parsed_chown.map(|parsed| parsed.spec().clone()),
        owner: context.owner,
        group: context.group,
        chmod: context.chmod.to_vec(),
        perms: context.perms,
        super_mode: context.super_mode,
        times: context.times,
        omit_dir_times: context.omit_dir_times,
        omit_link_times: context.omit_link_times,
        numeric_ids_option: context.numeric_ids_option,
        hard_links: context.hard_links,
        copy_links: context.copy_links,
        copy_dirlinks: context.copy_dirlinks,
        copy_unsafe_links: context.copy_unsafe_links,
        keep_dirlinks: context.keep_dirlinks,
        safe_links: context.safe_links,
        sparse: context.sparse,
        devices: context.devices,
        specials: context.specials,
        relative: context.relative,
        one_file_system: context.one_file_system,
        implied_dirs: context.implied_dirs,
        mkpath: context.mkpath,
        prune_empty_dirs: context.prune_empty_dirs,
        verbosity: context.verbosity,
        progress_enabled: context.progress_enabled,
        stats: context.stats,
        partial: context.partial,
        preallocate: context.preallocate,
        delay_updates: context.delay_updates,
        partial_dir: context.partial_dir.cloned(),
        temp_dir: context.temp_dir.cloned(),
        backup: context.backup,
        backup_dir: context.backup_dir.clone().map(PathBuf::from),
        backup_suffix: context.backup_suffix.clone(),
        link_dests: context.link_dests.to_vec(),
        remove_source_files: context.remove_source_files,
        append: append_for_fallback,
        append_verify: context.append_verify,
        inplace: context.inplace,
        msgs_to_stderr: context.msgs_to_stderr,
        whole_file_option: context.whole_file_option,
        fallback_bwlimit: context.fallback_bwlimit.cloned(),
        excludes: context.excludes.to_vec(),
        includes: context.includes.to_vec(),
        exclude_from: context.exclude_from.to_vec(),
        include_from: context.include_from.to_vec(),
        filters: context.filters.to_vec(),
        rsync_filter_shortcuts: context.rsync_filter_shortcuts,
        compare_destinations: context.compare_destinations.to_vec(),
        copy_destinations: context.copy_destinations.to_vec(),
        link_destinations: context.link_destinations.to_vec(),
        cvs_exclude: context.cvs_exclude,
        files_from_used: context.files_from_used,
        file_list_entries: context.file_list_entries.to_vec(),
        from0: context.from0,
        desired_protocol: context.desired_protocol,
        timeout: context.timeout,
        connect_timeout: context.connect_timeout,
        out_format: context.fallback_out_format.cloned(),
        no_motd: context.no_motd,
        address_mode: context.address_mode,
        rsync_path: context.rsync_path.cloned(),
        remainder: context.remainder.to_vec(),
        #[cfg(feature = "acl")]
        acls: context.acls,
        #[cfg(feature = "xattr")]
        xattrs: context.xattrs,
        itemize_changes: context.itemize_changes,
    };

    fallback::build_fallback_args(fallback_inputs, stderr)
}

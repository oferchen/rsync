#![allow(clippy::module_name_repetitions)]

//! # Overview
//!
//! The `signature` module produces rsync-compatible file signatures by
//! combining the block sizing heuristics from [`crate::delta`] with the rolling
//! and strong checksum primitives exposed by `rsync_checksums`. The resulting
//! signature stream mirrors the structure generated by upstream rsync's
//! `generator.c`: each block is described by a weak rolling checksum and a
//! strong digest that may be truncated according to the negotiated protocol.
//!
//! # Design
//!
//! - [`generate_file_signature`] accepts an input reader, the
//!   [`SignatureLayout`] obtained from
//!   [`crate::delta::calculate_signature_layout`], and a [`SignatureAlgorithm`]
//!   describing the strong checksum strategy. The helper reads each block in
//!   sequence, computes the weak and strong digests, and returns a
//!   [`FileSignature`] with deterministic ordering.
//! - [`FileSignature`] stores the layout alongside a vector of
//!   [`SignatureBlock`] entries so higher layers can iterate without
//!   recomputing metadata. The structure also records the total number of bytes
//!   consumed from the input to simplify validation in integration tests.
//! - [`SignatureAlgorithm`] enumerates the strong checksum algorithms supported
//!   by upstream rsync today (MD4/MD5/XXH64/XXH3). Each variant exposes the
//!   digest width, allowing the generator to truncate outputs in the same way
//!   rsync applies `checksum_len`.
//!
//! # Invariants
//!
//! - The number of blocks in the resulting [`FileSignature`] always matches the
//!   [`SignatureLayout::block_count`] supplied to
//!   [`generate_file_signature`]. When the layout reports zero blocks (e.g. an
//!   empty file), the signature contains no entries.
//! - Strong digests are truncated to the negotiated length, mirroring upstream
//!   rsync's behaviour. Requests for lengths exceeding the algorithm's
//!   capabilities produce [`SignatureError::DigestLengthMismatch`].
//! - Trailing data beyond the advertised layout results in
//!   [`SignatureError::TrailingData`], ensuring callers cannot accidentally
//!   ignore bytes that were not part of the original file length used during
//!   layout calculation.
//!
//! # Errors
//!
//! [`SignatureError`] distinguishes I/O failures, digest truncation mismatches,
//! and unexpected trailing data. The type implements [`std::error::Error`] and
//! converts from [`std::io::Error`], making it straightforward to bubble up
//! problems from higher layers without losing context.
//!
//! # Examples
//!
//! Generate a signature for an in-memory buffer using MD4 as the strong digest
//! algorithm. The resulting structure exposes one block because the file length
//! is smaller than the default block size.
//!
//! ```
//! use rsync_checksums::RollingDigest;
//! use rsync_engine::delta::{calculate_signature_layout, SignatureLayoutParams};
//! use rsync_engine::signature::{
//!     generate_file_signature, SignatureAlgorithm, SignatureError,
//! };
//! use rsync_protocol::ProtocolVersion;
//! use std::io::Cursor;
//! use std::num::NonZeroU8;
//!
//! # fn demo() -> Result<(), SignatureError> {
//! let params = SignatureLayoutParams::new(
//!     11,
//!     None,
//!     ProtocolVersion::NEWEST,
//!     NonZeroU8::new(16).unwrap(),
//! );
//! let layout = calculate_signature_layout(params).expect("layout");
//! let input = Cursor::new(b"hello world".to_vec());
//! let signature = generate_file_signature(
//!     input,
//!     layout,
//!     SignatureAlgorithm::Md4,
//! )?;
//!
//! assert_eq!(signature.blocks().len(), 1);
//! assert_eq!(signature.total_bytes(), 11);
//! assert_eq!(
//!     signature.blocks()[0].rolling(),
//!     RollingDigest::from_bytes(b"hello world")
//! );
//! # Ok(())
//! # }
//! # demo().unwrap();
//! ```
//!
//! # See also
//!
//! - [`crate::delta`] for the block sizing heuristics that produce the input
//!   [`SignatureLayout`].
//! - [`rsync_checksums`] for the rolling and strong checksum implementations
//!   reused by this module.

use core::fmt;
use std::io::{self, Read};
use std::num::NonZeroUsize;

use rsync_checksums::RollingDigest;
use rsync_checksums::strong::{Md4, Md5, Xxh3, Xxh3_128, Xxh64};

use crate::delta::SignatureLayout;

/// Strong checksum strategies supported by the signature generator.
#[derive(Clone, Copy, Debug, Eq, PartialEq)]
pub enum SignatureAlgorithm {
    /// MD4, used by upstream rsync for historical protocol versions.
    Md4,
    /// MD5, negotiated when both peers enable the checksum.
    Md5,
    /// XXH64, available in newer protocol combinations with an explicit seed.
    Xxh64 {
        /// Seed applied to the XXH64 instance.
        seed: u64,
    },
    /// XXH3/64, negotiated alongside modern protocol extensions.
    Xxh3 {
        /// Seed applied to the XXH3/64 instance.
        seed: u64,
    },
    /// XXH3/128, used when both peers support the extended checksum.
    Xxh3_128 {
        /// Seed applied to the XXH3/128 instance.
        seed: u64,
    },
}

impl SignatureAlgorithm {
    /// Returns the full digest width produced by the algorithm in bytes.
    #[must_use]
    pub const fn digest_len(self) -> usize {
        match self {
            SignatureAlgorithm::Md4 | SignatureAlgorithm::Md5 => 16,
            SignatureAlgorithm::Xxh64 { .. } | SignatureAlgorithm::Xxh3 { .. } => 8,
            SignatureAlgorithm::Xxh3_128 { .. } => 16,
        }
    }

    /// Computes a strong digest for `data`, returning the full-length output.
    fn compute_full(self, data: &[u8]) -> Vec<u8> {
        match self {
            SignatureAlgorithm::Md4 => Md4::digest(data).as_ref().to_vec(),
            SignatureAlgorithm::Md5 => Md5::digest(data).as_ref().to_vec(),
            SignatureAlgorithm::Xxh64 { seed } => Xxh64::digest(seed, data).as_ref().to_vec(),
            SignatureAlgorithm::Xxh3 { seed } => Xxh3::digest(seed, data).as_ref().to_vec(),
            SignatureAlgorithm::Xxh3_128 { seed } => Xxh3_128::digest(seed, data).as_ref().to_vec(),
        }
    }

    /// Computes a strong digest truncated to `len` bytes.
    pub(crate) fn compute_truncated(self, data: &[u8], len: usize) -> Vec<u8> {
        let mut digest = self.compute_full(data);
        if len < digest.len() {
            digest.truncate(len);
        }
        digest
    }
}

/// Describes a single block within a file signature.
#[derive(Clone, Debug, Eq, PartialEq)]
pub struct SignatureBlock {
    index: u64,
    rolling: RollingDigest,
    strong: Vec<u8>,
}

impl SignatureBlock {
    /// Creates a new block descriptor.
    const fn new(index: u64, rolling: RollingDigest, strong: Vec<u8>) -> Self {
        Self {
            index,
            rolling,
            strong,
        }
    }

    /// Returns the zero-based index of the block within the signature.
    #[must_use]
    pub const fn index(&self) -> u64 {
        self.index
    }

    /// Returns the rolling checksum digest associated with the block.
    #[must_use]
    pub const fn rolling(&self) -> RollingDigest {
        self.rolling
    }

    /// Returns the strong checksum bytes for the block.
    #[must_use]
    pub fn strong(&self) -> &[u8] {
        &self.strong
    }

    /// Returns the number of bytes that contributed to the rolling checksum.
    #[must_use]
    pub fn len(&self) -> usize {
        self.rolling.len()
    }

    /// Reports whether the block corresponds to an empty range.
    #[must_use]
    pub fn is_empty(&self) -> bool {
        self.len() == 0
    }
}

/// Aggregated signature for a file produced by [`generate_file_signature`].
#[derive(Clone, Debug, Eq, PartialEq)]
pub struct FileSignature {
    layout: SignatureLayout,
    blocks: Vec<SignatureBlock>,
    total_bytes: u64,
}

impl FileSignature {
    /// Creates a new signature container.
    const fn new(layout: SignatureLayout, blocks: Vec<SignatureBlock>, total_bytes: u64) -> Self {
        Self {
            layout,
            blocks,
            total_bytes,
        }
    }

    /// Returns the layout used to generate the signature.
    #[must_use]
    pub const fn layout(&self) -> SignatureLayout {
        self.layout
    }

    /// Returns the list of block entries in the order they were generated.
    #[must_use]
    pub fn blocks(&self) -> &[SignatureBlock] {
        &self.blocks
    }

    /// Returns the total number of bytes consumed while generating the signature.
    #[must_use]
    pub const fn total_bytes(&self) -> u64 {
        self.total_bytes
    }
}

/// Errors returned when generating file signatures.
#[derive(Debug)]
pub enum SignatureError {
    /// Underlying I/O failure raised while reading file contents.
    Io(io::Error),
    /// Requested strong checksum length exceeds what the algorithm can provide.
    DigestLengthMismatch {
        /// Strong checksum algorithm in use.
        algorithm: SignatureAlgorithm,
        /// Number of bytes requested by the layout.
        requested: NonZeroUsize,
    },
    /// Extra bytes were present in the input after consuming the advertised layout.
    TrailingData {
        /// Number of bytes observed beyond the expected layout.
        bytes: u64,
    },
    /// Number of blocks derived from the layout exceeded the platform's addressable range.
    TooManyBlocks(u64),
}

impl SignatureError {
    fn digest_mismatch(algorithm: SignatureAlgorithm, requested: usize) -> Self {
        let requested = NonZeroUsize::new(requested)
            .expect("strong digest length requested by layout must be non-zero");
        SignatureError::DigestLengthMismatch {
            algorithm,
            requested,
        }
    }
}

impl fmt::Display for SignatureError {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        match self {
            SignatureError::Io(error) => write!(
                f,
                "failed to read input while generating signature: {error}"
            ),
            SignatureError::DigestLengthMismatch {
                algorithm,
                requested,
            } => write!(
                f,
                "requested strong checksum length {requested} exceeds {algorithm:?} digest width"
            ),
            SignatureError::TrailingData { bytes } => write!(
                f,
                "input contained {bytes} trailing byte(s) beyond the expected layout"
            ),
            SignatureError::TooManyBlocks(blocks) => write!(
                f,
                "signature layout describes {blocks} blocks which exceeds addressable memory"
            ),
        }
    }
}

impl std::error::Error for SignatureError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match self {
            SignatureError::Io(error) => Some(error),
            SignatureError::DigestLengthMismatch { .. }
            | SignatureError::TrailingData { .. }
            | SignatureError::TooManyBlocks(_) => None,
        }
    }
}

impl From<io::Error> for SignatureError {
    fn from(error: io::Error) -> Self {
        SignatureError::Io(error)
    }
}

/// Generates an rsync-compatible file signature using the provided layout and strong checksum.
///
/// The reader must yield exactly the number of bytes implied by `layout`. Trailing data is
/// reported via [`SignatureError::TrailingData`].
///
/// # Errors
///
/// - Returns [`SignatureError::DigestLengthMismatch`] when the layout requests a strong checksum
///   length that exceeds the algorithm's digest width.
/// - Returns [`SignatureError::TooManyBlocks`] if the layout describes more blocks than can be
///   addressed on the current platform.
/// - Propagates any I/O error surfaced by the reader.
pub fn generate_file_signature<R: Read>(
    mut reader: R,
    layout: SignatureLayout,
    algorithm: SignatureAlgorithm,
) -> Result<FileSignature, SignatureError> {
    let strong_len = usize::from(layout.strong_sum_length().get());
    if strong_len > algorithm.digest_len() {
        return Err(SignatureError::digest_mismatch(algorithm, strong_len));
    }

    let block_len = layout.block_length().get() as usize;
    let expected_blocks = layout.block_count();
    let expected_blocks_usize = usize::try_from(expected_blocks)
        .map_err(|_| SignatureError::TooManyBlocks(expected_blocks))?;

    let mut blocks = Vec::with_capacity(expected_blocks_usize);
    let mut buffer = vec![0u8; block_len.max(1)];
    let mut total_bytes: u64 = 0;

    for index in 0..expected_blocks_usize {
        let is_last = index + 1 == expected_blocks_usize;
        let target_len = if is_last && layout.remainder() != 0 {
            layout.remainder() as usize
        } else {
            block_len
        };

        let chunk = &mut buffer[..target_len];
        reader.read_exact(chunk)?;
        let chunk = &chunk[..];
        total_bytes = total_bytes.saturating_add(target_len as u64);
        let rolling = RollingDigest::from_bytes(chunk);
        let mut strong = algorithm.compute_full(chunk);
        strong.truncate(strong_len);

        blocks.push(SignatureBlock::new(index as u64, rolling, strong));
    }

    let mut extra = [0u8; 1];
    if reader.read(&mut extra)? != 0 {
        return Err(SignatureError::TrailingData { bytes: 1 });
    }

    Ok(FileSignature::new(layout, blocks, total_bytes))
}

#[cfg(test)]
mod tests {
    use super::*;
    use crate::delta::{SignatureLayoutParams, calculate_signature_layout};
    use rsync_protocol::ProtocolVersion;
    use std::io::Cursor;
    use std::num::{NonZeroU8, NonZeroU32};

    fn layout(len: u64, checksum_len: u8) -> SignatureLayout {
        calculate_signature_layout(SignatureLayoutParams::new(
            len,
            None,
            ProtocolVersion::NEWEST,
            NonZeroU8::new(checksum_len).expect("checksum length"),
        ))
        .expect("layout")
    }

    #[test]
    fn generate_signature_single_block_md4() {
        let layout = layout(11, 16);
        let input = Cursor::new(b"hello world".to_vec());
        let signature = generate_file_signature(input, layout, SignatureAlgorithm::Md4)
            .expect("signature generation succeeds");

        assert_eq!(signature.blocks().len(), 1);
        let block = &signature.blocks()[0];
        assert_eq!(block.index(), 0);
        assert_eq!(block.len(), 11);
        assert_eq!(block.rolling(), RollingDigest::from_bytes(b"hello world"));
        assert_eq!(block.strong().len(), 16);
    }

    #[test]
    fn generate_signature_multiple_blocks_with_remainder() {
        let mut data = vec![0u8; 1_024 + 111];
        for (index, byte) in data.iter_mut().enumerate() {
            *byte = (index % 251) as u8;
        }
        let layout = calculate_signature_layout(SignatureLayoutParams::new(
            data.len() as u64,
            NonZeroU32::new(512),
            ProtocolVersion::NEWEST,
            NonZeroU8::new(16).unwrap(),
        ))
        .expect("layout");

        assert_eq!(layout.block_length().get(), 512);
        assert_eq!(layout.block_count(), 3);
        assert_eq!(layout.remainder(), 111);

        let signature =
            generate_file_signature(Cursor::new(data.clone()), layout, SignatureAlgorithm::Md5)
                .expect("signature generation succeeds");

        assert_eq!(signature.blocks().len(), 3);
        assert_eq!(signature.total_bytes(), data.len() as u64);

        for (index, block) in signature.blocks().iter().enumerate() {
            let start = index * 512;
            let end = if index == 2 { data.len() } else { start + 512 };
            assert_eq!(block.len(), end - start);
            assert_eq!(
                block.rolling(),
                RollingDigest::from_bytes(&data[start..end])
            );
        }
    }

    #[test]
    fn digest_length_mismatch_is_reported() {
        let layout = layout(256, 16);
        let result = generate_file_signature(
            Cursor::new(vec![0u8; 256]),
            layout,
            SignatureAlgorithm::Xxh64 { seed: 0 },
        );

        let error = result.expect_err("xxh64 cannot provide 16-byte digests");
        match error {
            SignatureError::DigestLengthMismatch {
                algorithm,
                requested,
            } => {
                assert_eq!(algorithm, SignatureAlgorithm::Xxh64 { seed: 0 });
                assert_eq!(requested.get(), 16);
            }
            other => panic!("unexpected error: {other:?}"),
        }
    }

    #[test]
    fn trailing_data_detected() {
        let layout = layout(32, 16);
        let mut data = vec![0u8; 32 + 1];
        data[32] = 1;
        let error = generate_file_signature(Cursor::new(data), layout, SignatureAlgorithm::Md4)
            .expect_err("trailing byte should be detected");

        assert!(matches!(error, SignatureError::TrailingData { .. }));
    }

    #[test]
    fn empty_files_produce_empty_signature() {
        let layout = layout(0, 16);
        let signature =
            generate_file_signature(Cursor::new(Vec::new()), layout, SignatureAlgorithm::Md4)
                .expect("signature generation succeeds");

        assert!(signature.blocks().is_empty());
        assert_eq!(signature.total_bytes(), 0);
    }
}

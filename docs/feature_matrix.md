# Feature Matrix — Rust rsync vs Upstream 3.4.1

The table below enumerates the major capability areas described in the
`Codex Mission Brief` and records the current implementation status in this
repository. Every entry is backed by code that exists today; missing
functionality explicitly calls out the absence of the relevant crate or
binary so documentation never overstates parity.

| Area | Feature | Status | Notes | Source |
|------|---------|--------|-------|--------|
| Protocol | Protocol version constants, selection helpers, and iteration utilities | Implemented | `ProtocolVersion` exposes `SUPPORTED_PROTOCOLS`, range helpers, and mutual selection logic used for negotiation parity. | `crates/protocol/src/version.rs` |
| Protocol | Legacy ASCII daemon greeting parsing (`@RSYNCD:`) | Implemented | Structured parsers cover banners, authentication prompts, and error/warning lines with exhaustive tests. | `crates/protocol/src/legacy/` |
| Protocol | Multiplexed message envelope (MSG_* tags, vectored writes) | Implemented | Envelope encoding/decoding mirrors upstream layouts and is fuzz/property tested. | `crates/protocol/src/envelope.rs`, `crates/protocol/src/multiplex.rs` |
| Protocol | Negotiation prologue sniffing (legacy vs binary) | Implemented | `NegotiationPrologueDetector` and sniffer utilities reconstruct buffered prefixes for replay. | `crates/protocol/src/negotiation/` |
| Protocol | Compatibility flags exchange & varint codec | Implemented | `CompatibilityFlags` models the post-handshake bitfield and reuses the upstream varint encoding for serialization. | `crates/protocol/src/compatibility.rs`, `crates/protocol/src/varint.rs` |
| Transport | Negotiation stream wrappers with prefix replay | Implemented | `NegotiatedStream` preserves the sniffed bytes, exposes `Read`/`BufRead`, returns the underlying reader for continued use, and provides helpers to parse legacy daemon messages/errors/warnings. | `crates/transport/src/negotiation.rs` |
| Transport | Legacy daemon handshake orchestration | Implemented | `daemon::negotiate_legacy_daemon_session` reads the ASCII greeting, selects the mutual protocol, emits the client banner, and returns the replaying stream together with the parsed metadata. | `crates/transport/src/daemon.rs` |
| Checksums | Rolling checksum (`rsum`) implementation | Implemented | Streaming `RollingChecksum` mirrors upstream `sum1`/`sum2` semantics and exposes safe rolling updates. | `crates/checksums/src/rolling.rs` |
| Checksums | Strong digests (MD4/MD5/SHA1/XXH64/XXH3) | Implemented | Streaming wrappers over RustCrypto hashes, `sha1`, and `xxhash-rust` provide the strong checksum variants negotiated by rsync; when the default `openssl-vendored` feature is enabled the MD4/MD5 wrappers transparently use OpenSSL's EVP implementations so the version banner advertises `openssl-crypto`. | `crates/checksums/src/strong/` |
| Core | Centralised message formatting with role/version trailers | Implemented | `core::message::Message` reproduces upstream `rsync error:`/`rsync warning:` prefixes, normalises source paths to repo-relative form, and appends `[role=3.4.1-rust]` trailers. | `crates/core/src/message.rs` |
| Core | Version metadata and standard banner formatting | Implemented | `version_metadata()` exposes upstream constants and renders the canonical `--version` banner (`oc-rsync  version 3.4.1-rust (revision/build #REV)  protocol version 32`, copyright notice, and a single `Source:` line pointing at the workspace repository) while matching upstream section layout. | `crates/core/src/version/mod.rs` |
| Core | Bandwidth limit parsing & pacing (`--bwlimit`) | Implemented | Shared helpers parse textual limits (decimal/binary/IEC units, fractional values, and `+1`/`-1` adjustments) and implement the token-bucket limiter reused by the client, engine, and daemon, including deterministic test instrumentation for pacing parity. | `crates/bandwidth/src/lib.rs`, `crates/core/src/client/mod.rs`, `crates/engine/src/local_copy.rs`, `crates/daemon/src/lib.rs` |
| Logging | Message sinks with newline policy and scratch-buffer reuse | Implemented | `MessageSink` wraps `io::Write`, reuses `MessageScratch`, and mirrors upstream newline handling for diagnostics while providing mapping/flush helpers. | `crates/logging/src/lib.rs` |
| Workspace | CLI front-end (`oc-rsync`) | Partial | The canonical `oc-rsync` binary recognises the primary rsync options used in P1 scenarios and drives deterministic transfers through the native Rust pipeline. Remote transports must use the Rust implementation; delegation to an external `rsync` binary is no longer permitted. Downstream packaging may add `rsync` symlinks if required, but the workspace ships only the unified binary. | `crates/cli`, `src/bin/oc-rsync.rs`, `crates/core/src/client/mod.rs` |
| Transport | Binary negotiation orchestration | Implemented | `binary::negotiate_binary_session` drives the remote-shell handshake, clamps the negotiated protocol, and returns the replaying stream together with the peer advertisement. | `crates/transport/src/binary.rs` |
| Transport | Unified session handshake facade | Implemented | `session::negotiate_session` routes to binary or legacy handshakes, reports negotiated/clamped protocol metadata, and rehydrates sniffers so callers can resume without replaying the transport. | `crates/transport/src/session/handshake.rs` |
| Workspace | Daemon server (`oc-rsync --daemon`) | Partial | Launching `oc-rsync --daemon` listens on a configurable TCP socket with explicit IPv4/IPv6 selection via `--ipv4`/`--ipv6`, completes the legacy handshake for sequential connections, advertises active features via `@RSYNCD: CAP …` lines (currently `modules` and `authlist`), serves `#list` requests using modules provided via `--module` or `--config` (subset of `rsyncd.conf`), emits configurable MOTD lines from `--motd-file`/`--motd-line` and global `motd`/`motd file` directives, enforces `hosts allow`/`hosts deny`, validates `auth users` credentials against the configured secrets file using the upstream challenge/response exchange, honours module-level `read only`/`write only`/`list` toggles together with `use chroot` directives (rejecting non-absolute paths when enabled) and applies global/module `incoming chmod`/`outgoing chmod` directives, caps simultaneous connections per module via the `max connections` directive, recognises runtime `--bwlimit`/`--no-bwlimit` toggles, and delegates authenticated module sessions to the system `rsync` binary by default (unless disabled via the `OC_RSYNC_*` overrides) while the native engine is completed. When built with `--features sd-notify`, the daemon emits `READY=1`, `STATUS=…`, and `STOPPING=1` notifications so the packaged systemd unit can track lifecycle events. Packaging ships only the unified `oc-rsync` binary; downstream environments may add compatibility symlinks if needed. | `crates/daemon/src/lib.rs`, `src/bin/oc-rsync.rs` |
| Workspace | Core transfer orchestration plus engine/meta/filter/compress crates | Partial | `core::client::run_client` now delegates to [`LocalCopyPlan`](../crates/engine/src/local_copy.rs) for deterministic local filesystem copies preserving permissions, timestamps, optional owner/group metadata, extended attributes, and (when the default `acl` feature is enabled) POSIX ACLs, and, when requested, deletes destination entries that are absent from the source while respecting `--max-delete` limits. Delta-transfer logic, comprehensive filter merging, compression, and remote transport orchestration remain pending. | `crates/core/src/client/mod.rs`, `crates/engine/src/local_copy.rs`, `crates/metadata/src/lib.rs` |
| Workspace | Deterministic filesystem walker | Implemented | `walk` provides a depth-first iterator that yields lexicographically ordered entries, enforces root-relative paths, and optionally follows directory symlinks while preventing cycles. | `crates/walk/src/lib.rs` |
| Quality | Golden parity harness & interop tests | Partial | Initial golden harness compares `oc-rsync --version` output against the upstream-captured expectation while holding locale/time settings constant; exit-code oracles, tree hashes, SSH coverage, and additional scenarios remain pending. | `tests/golden_cli.rs`, `tests/goldens/upstream/cli_version/` |
| Quality | Hygiene guards (LoC caps, placeholder ban) | Implemented | CI runs `tools/enforce_limits.sh` with a 600-line hard ceiling and rejects placeholder markers via `tools/no_placeholders.sh`, matching the hygiene agent's policy. | `.github/workflows/ci.yml`, `.github/workflows/lint.yml`, `tools/enforce_limits.sh`, `tools/no_placeholders.sh` |
| Quality | Packaging (deb/rpm), SBOM, systemd unit | Partial | `cargo-deb`/`cargo-rpm` metadata install the canonical oc-rsync entrypoint to `/usr/bin/oc-rsync` without shipping extra wrapper binaries, alongside a hardened systemd unit installed under the oc-specific name (so it can coexist with upstream `rsyncd.service` units), environment defaults, and sample configuration files placed at `/etc/oc-rsyncd/oc-rsyncd.conf` and `/etc/oc-rsyncd/oc-rsyncd.secrets`. SBOM artifacts are generated via `cargo xtask sbom`, which produces CycloneDX output directly from cargo metadata. Workspace branding data lives in `[workspace.metadata.oc_rsync]` so packaging automation validates program names and configuration paths before building artifacts, and the CI cross-compile dispatcher calls dedicated workflows that build Linux (x86_64, aarch64), macOS (x86_64, aarch64), and Windows (x86_64, aarch64) release binaries in parallel via `cargo zigbuild`. The Windows aarch64 lane remains present in the matrix but is disabled until the Zig toolchain ships stable native support, and the legacy Windows x86 target stays disabled to avoid toolchain clashes. | `Cargo.toml`, `Formula/oc-rsync.rb`, `tools/verify-brew-formula.sh`, `src/bin/oc-rsync.rs`, `packaging/systemd/oc-rsyncd.service`, `packaging/etc/oc-rsyncd/`, `xtask/src/main.rs`, `.github/workflows/cross-compile.yml`, `.github/workflows/build-linux.yml`, `.github/workflows/build-macos.yml`, `.github/workflows/build-windows.yml` |

Status legend: **Implemented** — behavior is present and backed by tests in this
repository. **Partial** — functionality exists but key capabilities are
disabled or incomplete pending follow-up work. **Missing** — code has not been
written yet; entries remain until the corresponding crates/binaries land and
parity is verified.

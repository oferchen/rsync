# Implementation Gaps

This document tracks the parity status of the Rust rsync workspace. Each entry reflects the
current repository state and can be regenerated by auditing the source tree.

## Implemented
- **Protocol negotiation primitives** (`crates/protocol`): legacy ASCII detection, binary vs.
  legacy prologue sniffing, envelope encoding/decoding, multiplex helpers, and protocol
  selection APIs (`select_highest_mutual`, `ProtocolVersion` constants) are implemented with
  exhaustive unit and property tests.
- **Legacy daemon parsing**: helpers for `@RSYNCD:` banners, error/warning lines, and
  authentication prompts mirror upstream structures and are exported for higher layers.
- **Legacy greeting metadata**: structured parsers expose advertised protocol numbers,
  subprotocol values, and digest lists so higher layers can reproduce upstream
  negotiation decisions without re-parsing raw strings.
- **Transport negotiation sniffing** (`crates/transport`): stream wrappers preserve the
  bytes consumed while determining the negotiation style, expose `Read`/`BufRead`
  views, and provide helpers to parse legacy daemon greetings, control messages,
  errors, and warnings so higher layers can replay the buffered prefix exactly as
  upstream rsync does.
- **Compatibility flag codec** (`crates/protocol`): `CompatibilityFlags` models the
  post-negotiation bitfield while the shared varint helpers encode/decode the
  byte representation used by upstream `write_varint()`/`read_varint()`.
- **Legacy daemon handshake orchestration** (`crates/transport`):
  `daemon::negotiate_legacy_daemon_session` performs the ASCII daemon handshake,
  clamps the negotiated protocol to the caller-provided cap, emits the client's
  greeting banner, and returns the replaying stream together with the parsed
  greeting metadata.
- **Binary negotiation orchestration** (`crates/transport`):
  `transport::negotiate_binary_session` drives the remote-shell handshake,
  writes the caller's advertised version, reads the peer's response via the
  replaying stream, validates the supported range, and returns the negotiated
  `ProtocolVersion` alongside the buffered transport wrapper.
- **Rolling and strong checksum primitives** (`crates/checksums`): exposes the `rsum`
  rolling checksum together with streaming MD4/MD5/XXH64 digests that match upstream
  algorithms, including error handling for invalid rolling-window usage.
- **Centralised message formatting** (`crates/core`): `Message` and `SourceLocation`
  reproduce upstream `rsync error:`/`rsync warning:` prefixes, append
  `[role=3.4.1-rust]` trailers, and normalise Rust `file!()` paths to
  repo-relative form for diagnostics.
- **Version constants and feature detection** (`crates/core::version`): exposes
  the canonical `3.4.1-rust` identifier together with helpers that surface
  compiled optional capabilities for future `--version` parity.

## Partial
- None at this time.

## Missing
- **Client and daemon orchestration**: the `cli` and `daemon` crates are absent
  and no binaries exist under `bin/`. The `core` crate currently offers message
  formatting and version reporting utilities but does not yet expose the
  `run_client`/`run_daemon` orchestration described in the workspace layout.
- **Transfer engine and supporting crates**: the `engine`, `meta`, `filters`, and
  `compress` crates remain unimplemented, so file selection, metadata
  application, and compression are unavailable.
- **Feature gating and runtime integration**: ACL/xattr, compression, metadata
  handling, and logging facades described in the workspace layout have not been
  implemented.
- **CI packaging and interop harnesses**: no automation exists for upstream comparisons,
  packaging, or coverage enforcement beyond unit tests in the protocol crate.

## Divergent
- None observed; existing modules target upstream rsync 3.4.1 semantics.

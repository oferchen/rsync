# Implementation Gaps

This document tracks the parity status of the Rust rsync workspace. Each entry reflects the
current repository state and can be regenerated by auditing the source tree.

## Implemented
- **Protocol negotiation primitives** (`crates/protocol`): legacy ASCII detection, binary vs.
  legacy prologue sniffing, envelope encoding/decoding, multiplex helpers, and protocol
  selection APIs (`select_highest_mutual`, `ProtocolVersion` constants) are implemented with
  exhaustive unit and property tests.
- **Legacy daemon parsing**: helpers for `@RSYNCD:` banners, error/warning lines, and
  authentication prompts mirror upstream structures and are exported for higher layers.
- **Legacy greeting metadata**: structured parsers expose advertised protocol numbers,
  subprotocol values, and digest lists so higher layers can reproduce upstream
  negotiation decisions without re-parsing raw strings.
- **Transport negotiation sniffing** (`crates/transport`): stream wrappers preserve the
  bytes consumed while determining the negotiation style, expose `Read`/`BufRead`
  views, and provide helpers to parse legacy daemon greetings, control messages,
  errors, and warnings so higher layers can replay the buffered prefix exactly as
  upstream rsync does.
- **Session handshake orchestration** (`crates/transport`): the `session`
  facade unifies binary and legacy handshakes, exposes cap/downgrade
  information, and rehydrates sniffers so higher layers can resume negotiation
  without replaying the underlying transport. The module also surfaces parts-based
  conversions that mirror upstream helpers for continuing with raw transports.
- **Compatibility flag codec** (`crates/protocol`): `CompatibilityFlags` models the
  post-negotiation bitfield while the shared varint helpers encode/decode the
  byte representation used by upstream `write_varint()`/`read_varint()`.
- **Legacy daemon handshake orchestration** (`crates/transport`):
  `daemon::negotiate_legacy_daemon_session` performs the ASCII daemon handshake,
  clamps the negotiated protocol to the caller-provided cap, emits the client's
  greeting banner, and returns the replaying stream together with the parsed
  greeting metadata.
- **Binary negotiation orchestration** (`crates/transport`):
  `transport::negotiate_binary_session` drives the remote-shell handshake,
  writes the caller's advertised version, reads the peer's response via the
  replaying stream, validates the supported range, and returns the negotiated
  `ProtocolVersion` alongside the buffered transport wrapper.
- **Rolling and strong checksum primitives** (`crates/checksums`): exposes the `rsum`
  rolling checksum together with streaming MD4/MD5/XXH64/XXH3 digests that match upstream
  algorithms, including error handling for invalid rolling-window usage.
- **Centralised message formatting** (`crates/core`): `Message` and `SourceLocation`
  reproduce upstream `rsync error:`/`rsync warning:` prefixes, append
  `[role=3.4.1-rust]` trailers, and normalise Rust `file!()` paths to
  repo-relative form for diagnostics.
- **Client diagnostic orchestration** (`crates/core::client`):
  [`run_client`](../crates/core/src/client.rs) centralises the feature-gap
  message that the CLI surfaces until the transfer engine lands, ensuring future
  binaries reuse the same wording and exit code.
- **Logging sinks for message emission** (`crates/logging`):
  [`MessageSink`](../crates/logging/src/lib.rs) wraps `io::Write`
  implementors, reuses `MessageScratch` buffers, and preserves upstream newline
  semantics through an explicit `LineMode` so higher layers can stream
  diagnostics without reimplementing rendering logic.
- **Version constants and feature detection** (`crates/core::version`): exposes
  the canonical `3.4.1-rust` identifier, helpers that surface compiled optional
  capabilities, and [`version_metadata()`](../crates/core/src/version.rs) for
  rendering the upstream `--version` banner.

## Partial
- None at this time.

## Missing
- **Client transfer orchestration**
  - *Impact*: The `rsync` binary now ships with the workspace but only supports
    `--help` and `--version`. Any attempt to perform a transfer exits with code
    `1` and reports that the delta-transfer engine has not been implemented.
  - *Removal plan*: Implement the CLI parser and option validation described in
    the workspace layout, extend `core::client::run_client` to drive the future
    transfer engine, and wire the resulting orchestration into the CLI so real
    synchronisation sessions can execute.
- **Daemon orchestration**
  - *Impact*: No `rsyncd` binary exists yet. Running daemon sessions or hosting
    modules is therefore impossible.
  - *Removal plan*: Introduce the `daemon` crate and transport loop, integrate
    it with the `core` facade, and verify functionality via the parity harness
    once the transfer pipeline lands.
- **Transfer engine and supporting crates**: the `engine`, `meta`, `filters`, and
  `compress` crates remain unimplemented. Consequently,
  [`core::client::run_client`](../crates/core/src/client.rs) reports a feature
  gap and no actual delta transfer or metadata application takes place.
- **Feature gating and runtime integration**: ACL/xattr, compression, metadata
  handling, and logging facades described in the workspace layout have not been
  implemented.
- **CI packaging and interop harnesses**: no automation exists for upstream comparisons,
  packaging, or coverage enforcement beyond unit tests in the protocol crate.

## Divergent
- None observed; existing modules target upstream rsync 3.4.1 semantics.
